# TodoApp Cursor AI Rules

## Project Overview

Enterprise-grade TodoApp built with React 19 + TypeScript 5.9 + Convex + **Tailwind CSS v4** + Shadcn UI, following TDD, SOLID principles, and security-first development.

**CRITICAL**: This project uses **Tailwind CSS v4**, which has completely different syntax from v3. Always use Context7 MCP to verify current syntax.

## Core Rules

### 1. Test-Driven Development (TDD)
- **ALWAYS** write tests BEFORE implementation
- Follow Red-Green-Refactor cycle
- All tests must pass before commit
- Target >80% coverage
- **NEVER** skip, disable, or mask failing tests

### 2. SOLID Principles
Apply to all code:
- **S**: Single Responsibility - one purpose per component/function
- **O**: Open/Closed - open for extension, closed for modification
- **L**: Liskov Substitution - subtypes must be substitutable
- **I**: Interface Segregation - no unnecessary dependencies
- **D**: Dependency Inversion - depend on abstractions

### 3. Type Safety
- TypeScript strict mode enabled
- **NO `any` types** without justification
- All parameters and returns explicitly typed
- All variables properly typed

### 4. Styling (CRITICAL)

**IMPORTANT**: This project uses **Tailwind CSS v4**, not v3!

**Tailwind v4 Syntax**:
- Use `@import "tailwindcss"` (NOT `@tailwind base/components/utilities`)
- Use `@theme` blocks (NOT `@layer base` for CSS variables)
- Use OKLCH colors (NOT HSL)
- Use `--color-*` naming (NOT `--*` alone)
- Simplified config (no `theme.extend.colors` needed)

**Before writing CSS**:
1. **ALWAYS** use Context7 MCP to check Tailwind v4 syntax
2. Check `package.json` for version
3. Verify existing `index.css` patterns

**Component Styling**:
- **NEVER** use inline styles (`style={{...}}`)
- **ALWAYS** use Shadcn UI components as base
- **ALWAYS** use Tailwind utility classes
- **ALWAYS** use theme variables (`var(--color-primary)`)

```typescript
// ❌ FORBIDDEN
<div style={{ backgroundColor: 'blue' }}>

// ✅ REQUIRED
<Card className="bg-card">
  <CardContent>
```

### 5. Security (MANDATORY)
- Check authentication in ALL protected Convex queries/mutations
- Verify authorization (user owns resource)
- Validate ALL inputs (backend AND frontend)
- Never trust client-side validation alone
- Never log sensitive data (PII, passwords, tokens)
- Use environment variables for secrets

### 6. Component Patterns
- Container/Presentational pattern
- Container = data + logic
- Presentational = pure rendering
- Extract complex logic to custom hooks
- Use Shadcn components for all UI

### 7. Error Handling
- Wrap async operations in try-catch
- Log errors with context (no sensitive data)
- Show user-friendly messages
- **NEVER** silence or hide errors
- Always re-throw for upstream handling

## Backend Pattern (Convex)

```typescript
export const query = query({
  args: { /* validators */ },
  handler: async (ctx, args) => {
    // 1. ALWAYS check authentication
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error('Unauthorized');
    
    // 2. Query with user isolation
    const data = await ctx.db
      .query('table')
      .withIndex('by_user', q => q.eq('userId', identity.subject))
      .collect();
    
    return data;
  },
});

export const mutation = mutation({
  args: { /* validators */ },
  handler: async (ctx, args) => {
    // 1. ALWAYS check authentication
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error('Unauthorized');
    
    // 2. ALWAYS validate input
    if (!args.value.trim()) throw new Error('Invalid input');
    
    // 3. Check authorization if updating/deleting
    const resource = await ctx.db.get(args.id);
    if (resource.userId !== identity.subject) {
      throw new Error('Forbidden');
    }
    
    // 4. Execute operation
    const result = await ctx.db.insert('table', { /* data */ });
    return result;
  },
});
```

## Frontend Pattern

```typescript
// Container (Smart) - handles data and logic
function FeatureContainer() {
  const data = useQuery(api.feature.list);
  const mutate = useMutation(api.feature.create);
  
  const handleAction = useCallback(async (input: string) => {
    try {
      await mutate({ input });
      toast.success('Success');
    } catch (error) {
      console.error('Action failed:', error);
      toast.error('Failed');
      throw error;
    }
  }, [mutate]);
  
  if (data === undefined) return <Skeleton />;
  
  return <FeaturePresenter data={data} onAction={handleAction} />;
}

// Presenter (Dumb) - pure rendering
interface FeaturePresenterProps {
  data: DataType[];
  onAction: (input: string) => void;
}

function FeaturePresenter({ data, onAction }: FeaturePresenterProps) {
  return (
    <Card>
      <CardContent>
        {/* Pure rendering with Shadcn components */}
      </CardContent>
    </Card>
  );
}
```

## Before Committing

Run these commands - **ALL must pass**:

```bash
npm test                # Tests pass
npm run lint            # No ESLint errors
npm run build           # Build succeeds
npx tsc --noEmit        # No TypeScript errors
```

## Quality Checklist

- [ ] Tests written FIRST (TDD)
- [ ] All tests passing (>80% coverage)
- [ ] No TypeScript errors
- [ ] No ESLint errors
- [ ] Security checked (auth + input validation + error handling)
- [ ] SOLID principles applied
- [ ] No inline styles (theme-based only)
- [ ] Shadcn components used
- [ ] Error handling proper

## Common Mistakes to Avoid

### ❌ NEVER
- Use inline styles
- Skip writing tests first
- Use `any` type
- Skip authentication checks
- Skip input validation
- Hide or mask errors
- Commit with failing tests
- Log sensitive data
- Hardcode secrets

### ✅ ALWAYS
- Write tests before code (TDD)
- Use theme-based styling (Shadcn + Tailwind)
- Check authentication in Convex
- Validate all inputs
- Handle errors properly
- Follow SOLID principles
- Use TypeScript strict mode
- Run quality checks before commit

## Documentation

Reference these for detailed guidance:

- **`/docs/DEVELOPMENT.md`** - Coding practices, TDD, security, testing
- **`/docs/ARCHITECTURE.md`** - Design patterns and architecture
- **`/docs/DEPLOYMENT.md`** - Deployment and CI/CD
- **`/docs/PROJECT_PLAN.md`** - Implementation roadmap

## MCP Tools (MANDATORY)

### Context7 MCP - ALWAYS Use First
**CRITICAL**: Before using ANY library syntax, use Context7 to verify:
1. **Installed version** (e.g., Tailwind v4 vs v3)
2. **Current syntax** (major versions have breaking changes)
3. **Best practices** for that specific version

Example: Check Tailwind v4 documentation before writing CSS:
```
Use Context7: "Tailwind CSS v4 @theme syntax"
```

### Other MCP Tools
- **Convex MCP**: Backend operations (status, data, functions, logs)
- **Shadcn MCP**: Component search and installation
- **Browser MCP**: Visual verification of styling

### Workflow
1. **Context7** → Check library version and syntax
2. **Implement** → Write code using correct syntax
3. **Browser MCP** → Visually verify results
4. **Tests** → Ensure functionality

## Example Code

### Good Example ✅
```typescript
interface TodoItemProps {
  todo: Todo;
  onDelete: (id: string) => void;
}

export function TodoItem({ todo, onDelete }: TodoItemProps) {
  const handleDelete = useCallback(() => {
    onDelete(todo._id);
  }, [todo._id, onDelete]);
  
  return (
    <Card className="p-4">
      <CardContent>
        <h3 className="text-lg font-semibold">{todo.title}</h3>
        <Button 
          variant="destructive" 
          onClick={handleDelete}
          aria-label="Delete todo"
        >
          Delete
        </Button>
      </CardContent>
    </Card>
  );
}
```

### Bad Example ❌
```typescript
export function TodoItem({ todo, onDelete }: any) { // ❌ any type
  return (
    <div style={{ padding: '20px' }}> {/* ❌ inline style */}
      <h3>{todo.title}</h3>
      <button onClick={() => onDelete(todo._id)}> {/* ❌ not Shadcn */}
        Delete
      </button>
    </div>
  );
}
// ❌ Missing: Tests, proper types, Shadcn components, theme styling
```

## Response Format

When generating code:
1. **FIRST**: Check library versions with Context7 if using external libraries
2. Clarify requirements if unclear
3. Reference documentation when relevant
4. Write tests FIRST (TDD)
5. Implement following all rules (including correct library syntax)
6. Include error handling
7. Use proper TypeScript types
8. Follow established patterns
9. Add comments for complex logic
10. Verify visually with Browser MCP when styling

## Priority Order

1. **Security** - Always first
2. **Tests** - TDD approach
3. **Type Safety** - Strict TypeScript
4. **Code Quality** - SOLID, DRY, clean code
5. **Performance** - Optimize appropriately
6. **Documentation** - Keep current

---

**Key Principle**: Tests are required (TDD), security is mandatory, inline styles are forbidden, and type safety is non-negotiable. When in doubt, check `/docs/` for detailed guidance.
