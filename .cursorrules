# TodoApp Cursor AI Rules

## Project Overview

Enterprise-grade TodoApp built with React + TypeScript + Convex + Tailwind + Shadcn UI, following TDD, SOLID principles, and security-first development.

## Core Rules

### 1. Test-Driven Development (TDD)
- **ALWAYS** write tests BEFORE implementation
- Follow Red-Green-Refactor cycle
- All tests must pass before commit
- Target >80% coverage
- **NEVER** skip, disable, or mask failing tests

### 2. SOLID Principles
Apply to all code:
- **S**: Single Responsibility - one purpose per component/function
- **O**: Open/Closed - open for extension, closed for modification
- **L**: Liskov Substitution - subtypes must be substitutable
- **I**: Interface Segregation - no unnecessary dependencies
- **D**: Dependency Inversion - depend on abstractions

### 3. Type Safety
- TypeScript strict mode enabled
- **NO `any` types** without justification
- All parameters and returns explicitly typed
- All variables properly typed

### 4. Styling (CRITICAL)
- **NEVER** use inline styles (`style={{...}}`)
- **ALWAYS** use Shadcn UI components as base
- **ALWAYS** use Tailwind utility classes
- **ALWAYS** use theme variables from theme.css

```typescript
// ❌ FORBIDDEN
<div style={{ backgroundColor: 'blue' }}>

// ✅ REQUIRED
<Card className="bg-card">
  <CardContent>
```

### 5. Security (MANDATORY)
- Check authentication in ALL protected Convex queries/mutations
- Verify authorization (user owns resource)
- Validate ALL inputs (backend AND frontend)
- Never trust client-side validation alone
- Never log sensitive data (PII, passwords, tokens)
- Use environment variables for secrets

### 6. Component Patterns
- Container/Presentational pattern
- Container = data + logic
- Presentational = pure rendering
- Extract complex logic to custom hooks
- Use Shadcn components for all UI

### 7. Error Handling
- Wrap async operations in try-catch
- Log errors with context (no sensitive data)
- Show user-friendly messages
- **NEVER** silence or hide errors
- Always re-throw for upstream handling

## Backend Pattern (Convex)

```typescript
export const query = query({
  args: { /* validators */ },
  handler: async (ctx, args) => {
    // 1. ALWAYS check authentication
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error('Unauthorized');
    
    // 2. Query with user isolation
    const data = await ctx.db
      .query('table')
      .withIndex('by_user', q => q.eq('userId', identity.subject))
      .collect();
    
    return data;
  },
});

export const mutation = mutation({
  args: { /* validators */ },
  handler: async (ctx, args) => {
    // 1. ALWAYS check authentication
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error('Unauthorized');
    
    // 2. ALWAYS validate input
    if (!args.value.trim()) throw new Error('Invalid input');
    
    // 3. Check authorization if updating/deleting
    const resource = await ctx.db.get(args.id);
    if (resource.userId !== identity.subject) {
      throw new Error('Forbidden');
    }
    
    // 4. Execute operation
    const result = await ctx.db.insert('table', { /* data */ });
    return result;
  },
});
```

## Frontend Pattern

```typescript
// Container (Smart) - handles data and logic
function FeatureContainer() {
  const data = useQuery(api.feature.list);
  const mutate = useMutation(api.feature.create);
  
  const handleAction = useCallback(async (input: string) => {
    try {
      await mutate({ input });
      toast.success('Success');
    } catch (error) {
      console.error('Action failed:', error);
      toast.error('Failed');
      throw error;
    }
  }, [mutate]);
  
  if (data === undefined) return <Skeleton />;
  
  return <FeaturePresenter data={data} onAction={handleAction} />;
}

// Presenter (Dumb) - pure rendering
interface FeaturePresenterProps {
  data: DataType[];
  onAction: (input: string) => void;
}

function FeaturePresenter({ data, onAction }: FeaturePresenterProps) {
  return (
    <Card>
      <CardContent>
        {/* Pure rendering with Shadcn components */}
      </CardContent>
    </Card>
  );
}
```

## Before Committing

Run these commands - **ALL must pass**:

```bash
npm test                # Tests pass
npm run lint            # No ESLint errors
npm run build           # Build succeeds
npx tsc --noEmit        # No TypeScript errors
```

## Quality Checklist

- [ ] Tests written FIRST (TDD)
- [ ] All tests passing (>80% coverage)
- [ ] No TypeScript errors
- [ ] No ESLint errors
- [ ] Security checked (auth + input validation + error handling)
- [ ] SOLID principles applied
- [ ] No inline styles (theme-based only)
- [ ] Shadcn components used
- [ ] Error handling proper

## Common Mistakes to Avoid

### ❌ NEVER
- Use inline styles
- Skip writing tests first
- Use `any` type
- Skip authentication checks
- Skip input validation
- Hide or mask errors
- Commit with failing tests
- Log sensitive data
- Hardcode secrets

### ✅ ALWAYS
- Write tests before code (TDD)
- Use theme-based styling (Shadcn + Tailwind)
- Check authentication in Convex
- Validate all inputs
- Handle errors properly
- Follow SOLID principles
- Use TypeScript strict mode
- Run quality checks before commit

## Documentation

Reference these for detailed guidance:

- **`/docs/DEVELOPMENT.md`** - Coding practices, TDD, security, testing
- **`/docs/ARCHITECTURE.md`** - Design patterns and architecture
- **`/docs/DEPLOYMENT.md`** - Deployment and CI/CD
- **`/docs/PROJECT_PLAN.md`** - Implementation roadmap

## MCP Tools

- **Convex MCP**: Backend operations (status, data, functions, logs)
- **Shadcn MCP**: Component search and installation
- **Context7 MCP**: Current library documentation

## Example Code

### Good Example ✅
```typescript
interface TodoItemProps {
  todo: Todo;
  onDelete: (id: string) => void;
}

export function TodoItem({ todo, onDelete }: TodoItemProps) {
  const handleDelete = useCallback(() => {
    onDelete(todo._id);
  }, [todo._id, onDelete]);
  
  return (
    <Card className="p-4">
      <CardContent>
        <h3 className="text-lg font-semibold">{todo.title}</h3>
        <Button 
          variant="destructive" 
          onClick={handleDelete}
          aria-label="Delete todo"
        >
          Delete
        </Button>
      </CardContent>
    </Card>
  );
}
```

### Bad Example ❌
```typescript
export function TodoItem({ todo, onDelete }: any) { // ❌ any type
  return (
    <div style={{ padding: '20px' }}> {/* ❌ inline style */}
      <h3>{todo.title}</h3>
      <button onClick={() => onDelete(todo._id)}> {/* ❌ not Shadcn */}
        Delete
      </button>
    </div>
  );
}
// ❌ Missing: Tests, proper types, Shadcn components, theme styling
```

## Response Format

When generating code:
1. Clarify requirements if unclear
2. Reference documentation when relevant
3. Write tests FIRST (TDD)
4. Implement following all rules
5. Include error handling
6. Use proper TypeScript types
7. Follow established patterns
8. Add comments for complex logic

## Priority Order

1. **Security** - Always first
2. **Tests** - TDD approach
3. **Type Safety** - Strict TypeScript
4. **Code Quality** - SOLID, DRY, clean code
5. **Performance** - Optimize appropriately
6. **Documentation** - Keep current

---

**Key Principle**: Tests are required (TDD), security is mandatory, inline styles are forbidden, and type safety is non-negotiable. When in doubt, check `/docs/` for detailed guidance.
